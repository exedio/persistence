/*
 * Copyright (C) 2004-2012  exedio GmbH (www.exedio.com)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package com.exedio.cope.instrument;

import static java.lang.reflect.Modifier.FINAL;
import static java.lang.reflect.Modifier.PRIVATE;
import static java.lang.reflect.Modifier.STATIC;
import static java.text.MessageFormat.format;

import com.exedio.cope.ActivationParameters;
import com.exedio.cope.BooleanField;
import com.exedio.cope.Feature;
import com.exedio.cope.Item;
import com.exedio.cope.SetValue;
import com.exedio.cope.Type;
import com.exedio.cope.TypesBound;
import com.exedio.cope.pattern.Block;
import com.exedio.cope.pattern.BlockActivationParameters;
import com.exedio.cope.pattern.BlockType;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;

final class Generator
{
	private static final String SET_VALUE = SetValue.class.getName();
	private static final String TYPE_NAME = Type.class.getName();
	private static final String TYPES_BOUND_NAME = TypesBound.class.getName();
	private static final String BLOCK_TYPE_NAME = BlockType.class.getName();
	private static final String ACTIVATION = ActivationParameters.class.getName();
	private static final String ACTIVATION_BLOCK = BlockActivationParameters.class.getCanonicalName();
	private static final String OVERRIDE = Override.class.getName();

	private static final String CONSTRUCTOR_INITIAL = "Creates a new {0} with all the fields initially needed.";
	private static final String CONSTRUCTOR_INITIAL_PARAMETER = "the initial value for field {0}.";
	private static final String CONSTRUCTOR_INITIAL_CUSTOMIZE = "It can be customized with the tags " +
																					"<tt>@" + CopeType.TAG_INITIAL_CONSTRUCTOR + ' ' +
																					Option.TEXT_VISIBILITY_PUBLIC + '|' +
																					Option.TEXT_VISIBILITY_PACKAGE + '|' +
																					Option.TEXT_VISIBILITY_PROTECTED + '|' +
																					Option.TEXT_VISIBILITY_PRIVATE + '|' +
																					Option.TEXT_NONE +
																					"</tt> " +
																					"in the class comment and " +
																					"<tt>@" + CopeFeature.TAG_INITIAL + "</tt> in the comment of fields.";
	private static final String CONSTRUCTOR_GENERIC = "Creates a new {0} and sets the given fields initially.";
	private static final String CONSTRUCTOR_GENERIC_CUSTOMIZE = "It can be customized with the tag " +
																					"<tt>@" + CopeType.TAG_GENERIC_CONSTRUCTOR + ' ' +
																					Option.TEXT_VISIBILITY_PUBLIC + '|' +
																					Option.TEXT_VISIBILITY_PACKAGE + '|' +
																					Option.TEXT_VISIBILITY_PROTECTED + '|' +
																					Option.TEXT_VISIBILITY_PRIVATE + '|' +
																					Option.TEXT_NONE +
																					"</tt> " +
																					"in the class comment.";
	private static final String CONSTRUCTOR_ACTIVATION = "Activation constructor. Used for internal purposes only.";
	private static final String TYPE = "The persistent type information for {0}.";
	private static final String TYPE_BLOCK = "The type information for {0}.";
	private static final String TYPE_CUSTOMIZE = "It can be customized with the tag " +
																"<tt>@" + CopeType.TAG_TYPE + ' ' +
																Option.TEXT_VISIBILITY_PUBLIC + '|' +
																Option.TEXT_VISIBILITY_PACKAGE + '|' +
																Option.TEXT_VISIBILITY_PROTECTED + '|' +
																Option.TEXT_VISIBILITY_PRIVATE + '|' +
																Option.TEXT_NONE +
																"</tt> " +
																"in the class comment.";
	private static final String GENERATED = "This feature has been generated by the cope instrumentor and will be overwritten by the build process.";

	/**
	 * All generated class features get this doccomment tag.
	 */
	static final String TAG_GENERATED = CopeFeature.TAG_PREFIX + "generated";


	private final JavaFile javaFile;
	private final StringBuilder output;
	private final String lineSeparator;
	private final boolean longJavadoc;
	private final String finalArgPrefix;
	private final boolean suppressUnusedWarningOnPrivateActivationConstructor;
	private final boolean serialVersionUID;
	private final boolean genericSetValueArray;
	private final boolean directSetValueMap;
	private final String hidingWarningSuppressor;
	private int typeIndent = Integer.MIN_VALUE;


	Generator(final JavaFile javaFile, final StringBuilder output, final Params params)
	{
		this.javaFile = javaFile;
		this.output = output;

		final String systemLineSeparator = System.getProperty("line.separator");
		if(systemLineSeparator==null)
		{
			System.out.println("warning: property \"line.separator\" is null, using LF (unix style).");
			lineSeparator = "\n";
		}
		else
			lineSeparator = systemLineSeparator;

		this.longJavadoc = params.longJavadoc;
		this.finalArgPrefix = params.finalArgs ? "final " : "";
		this.suppressUnusedWarningOnPrivateActivationConstructor = params.suppressUnusedWarningOnPrivateActivationConstructor;
		this.serialVersionUID = params.serialVersionUID;
		this.genericSetValueArray = params.genericSetValueArray;
		this.directSetValueMap = params.directSetValueMap;
		this.hidingWarningSuppressor = params.hidingWarningSuppressor;
	}

	private static final String toCamelCase(final String name)
	{
		final char first = name.charAt(0);
		if (Character.isUpperCase(first))
			return name;
		else
			return Character.toUpperCase(first) + name.substring(1);
	}

	private static final String lowerCamelCase(final String s)
	{
		final char first = s.charAt(0);
		if(Character.isLowerCase(first))
			return s;
		else
			return Character.toLowerCase(first) + s.substring(1);
	}

	private void writeThrowsClause(final Collection<Class<? extends Throwable>> exceptions)
	{
		if(!exceptions.isEmpty())
		{
			writeIndent(2);
			write("throws");
			final CharSeparator comma = new CharSeparator(',');
			for(final Class<? extends Throwable> e : exceptions)
			{
				comma.appendTo(output);
				write(lineSeparator);
				writeIndent(3);
				write(e.getCanonicalName());
			}
			write(lineSeparator);
		}
	}

	private void writeCommentHeader()
	{
		write("/**");
		write(lineSeparator);
		if(longJavadoc)
		{
			write(lineSeparator);
			writeIndent();
			write(" **");
			write(lineSeparator);
		}
	}

	private void writeCommentFooter()
	{
		writeCommentFooter(null);
	}

	private void writeCommentFooter(final String extraComment)
	{
		writeIndent();
		write(" * @" + TAG_GENERATED + ' ');
		write(GENERATED);
		write(lineSeparator);
		if(extraComment!=null)
		{
			writeIndent();
			write(" *       ");
			write(extraComment);
			write(lineSeparator);
		}
		writeIndent();
		write(" */");
		write(lineSeparator);
	}

	private static final String link(final String target)
	{
		return "{@link #" + target + '}';
	}

	private void writeInitialConstructor(final CopeType type)
	{
		if(type.isBlock)
			return;
		if(!type.hasInitialConstructor())
			return;

		final List<CopeFeature> initialFeatures = type.getInitialFeatures();
		final SortedSet<Class<? extends Throwable>> constructorExceptions = type.getConstructorExceptions();

		writeCommentHeader();
		writeIndent();
		write(" * ");
		write(format(CONSTRUCTOR_INITIAL, type.name));
		write(lineSeparator);
		for(final CopeFeature feature : initialFeatures)
		{
			writeIndent();
			write(" * @param ");
			write(feature.name);
			write(' ');
			write(format(CONSTRUCTOR_INITIAL_PARAMETER, link(feature.name)));
			write(lineSeparator);
		}
		for(final Class<?> constructorException : constructorExceptions)
		{
			final ConstructorComment a = constructorException.getAnnotation(ConstructorComment.class);
			if(a==null)
				continue;

			writeIndent();
			write(" * @throws ");
			write(constructorException.getCanonicalName());
			write(' ');

			final StringSeparator comma = new StringSeparator(", ");
			final StringBuilder fields = new StringBuilder();
			for(final CopeFeature feature : initialFeatures)
			{
				if(!feature.getInitialExceptions().contains(constructorException))
					continue;

				comma.appendTo(fields);
				fields.append(feature.name);
			}

			final String pattern = a.value();
			write(format(pattern, fields.toString()));
			write(lineSeparator);
		}
		writeCommentFooter(CONSTRUCTOR_INITIAL_CUSTOMIZE);

		writeIndent();
		writeModifier(type.getInitialConstructorModifier());
		write(type.name);
		write('(');

		final CharSeparator comma = new CharSeparator(',');
		for(final CopeFeature feature : initialFeatures)
		{
			comma.appendTo(output);
			write(lineSeparator);
			writeIndent(3);
			write(finalArgPrefix);
			write(new Context(feature, feature.parent!=type).write(feature.getInitialType()));
			write(' ');
			write(feature.name);
		}

		write(')');
		write(lineSeparator);
		writeThrowsClause(constructorExceptions);
		writeIndent();
		write('{');
		write(lineSeparator);
		writeIndent(1);
		write("this(new " + SET_VALUE);
		if(genericSetValueArray)
			write("<?>");
		write("[]{");
		write(lineSeparator);
		for(final CopeFeature feature : initialFeatures)
		{
			writeIndent(2);
			if(directSetValueMap)
				write(SET_VALUE + ".map(");
			final CopeType parent = feature.parent;
			if(parent==type)
				write(type.name);
			else
				write(parent.javaClass.getFullName());
			write('.');
			write(feature.name);
			if(directSetValueMap)
				write(',');
			else
				write(".map(");
			write(feature.name);
			write("),");
			write(lineSeparator);
		}
		writeIndent(1);
		write("});");
		write(lineSeparator);
		writeIndent();
		write('}');
	}

	private void writeGenericConstructor(final CopeType type)
	{
		if(type.isBlock)
			return;

		final Option option = type.genericConstructorOption;
		if(!option.exists)
			return;

		writeCommentHeader();
		writeIndent();
		write(" * ");
		write(format(CONSTRUCTOR_GENERIC, type.name));
		write(lineSeparator);
		writeCommentFooter(CONSTRUCTOR_GENERIC_CUSTOMIZE);

		writeIndent();
		writeModifier(option.getModifier(type.getSubtypeModifier()));
		write(type.name);
		write('(');
		write(finalArgPrefix);
		write(SET_VALUE + "<?>... setValues)");
		write(lineSeparator);
		writeIndent();
		write('{');
		write(lineSeparator);
		writeIndent(1);
		write("super(setValues);");
		write(lineSeparator);
		writeIndent();
		write('}');
	}

	private void writeActivationConstructor(final CopeType type)
	{
		if(type.isComposite)
			return;

		final Option option = type.activationConstructorOption;
		if(!option.exists)
			return;

		final boolean block = type.isBlock;
		final Class<?> constructor = block ? Block.class : Item.class;
		final String activation = block ? ACTIVATION_BLOCK : ACTIVATION;

		writeCommentHeader();
		writeIndent();
		write(" * ");
		write(CONSTRUCTOR_ACTIVATION);
		write(lineSeparator);
		writeIndent();
		write(" * @see ");
		write(constructor.getName());
		write('#');
		write(constructor.getSimpleName());
		write('(');
		write(activation);
		write(')');
		write(lineSeparator);
		writeCommentFooter();

		writeIndent();
		if(suppressUnusedWarningOnPrivateActivationConstructor && !type.allowSubtypes())
			write("@SuppressWarnings(\"unused\") ");
		writeModifier(option.getModifier(type.getSubtypeModifier()));
		write(type.name);
		write('(');
		write(finalArgPrefix);
		write(block ? ACTIVATION_BLOCK : ACTIVATION);
		write(" ap){super(ap);");
		write(lineSeparator);
		write('}');
	}

	private void writeFeature(final CopeFeature feature)
	throws ParserException
	{
		final Feature instance = feature.getInstance();
		final JavaClass javaClass = feature.getParent();
		for(final WrapperX wrapper : getWrappers(instance))
		{
			final String pattern = wrapper.getMethodWrapperPattern();
			final String modifierTag = wrapper.getOptionTagName()!=null ? wrapper.getOptionTagName() : pattern!=null ? format(pattern, "", "") : wrapper.getName();
			final Option option = new Option(Tags.getLine(feature.docComment, CopeFeature.TAG_PREFIX + modifierTag), true);

			if(!option.exists)
				continue;
			if(feature.parent.isBlock && wrapper.hasStaticClassToken())
				continue;

			final Context ctx = new Context(feature, wrapper);
			final String methodName = wrapper.getName();
			final java.lang.reflect.Type methodReturnType = wrapper.getReturnType();
			final List<WrapperX.Parameter> parameters = wrapper.getParameters();
			final Map<Class<? extends Throwable>, String[]> throwsClause = wrapper.getThrowsClause();
			final String featureNameCamelCase = toCamelCase(feature.name);
			final boolean isStatic = wrapper.isStatic();
			final int modifier = feature.modifier;
			final boolean useIs = instance instanceof BooleanField && methodName.startsWith("get");

			final Object[] arguments = new String[]{
					link(feature.name),
					feature.name,
					lowerCamelCase(feature.parent.name),
					featureNameCamelCase};
			{
				writeCommentHeader();
				writeCommentParagraph("", " ", wrapper.getCommentArray(), arguments);

				for(final WrapperX.Parameter parameter : wrapper.getParameters())
				{
					if(parameter.varargs!=null)
					{
						for(final Object parameterInstanceO : parameter.varargs)
						{
							final Feature parameterInstance = (Feature)parameterInstanceO;
							final JavaField fei = javaClass.getFieldByInstance(parameterInstance);
							final CopeFeature fau = feature.parent.getFeature(fei.name);

							// TODO separate test -------------------------------------------------------------
							final Object[] parameterArguments = new String[]{
									link(fau.name),
									fau.name,
									lowerCamelCase(fau.parent.name)};
							writeCommentParagraph(
									"@param " + format(fei.name, parameterArguments),
									"        ",
									parameter.getComment(), parameterArguments);
						}
					}
					else
					{
						writeCommentParagraph(
								"@param " + format(parameter.getName(), arguments),
								"        ",
								parameter.getComment(), arguments);
					}
				}
				writeCommentParagraph(
						"@return",
						"         ",
						wrapper.getReturnComment(), arguments);

				for(final Map.Entry<Class<? extends Throwable>, String[]> e : throwsClause.entrySet())
				{
					writeCommentParagraph(
							"@throws " + e.getKey().getCanonicalName(),
							"         ",
							e.getValue(), arguments);
				}
				writeCommentFooter(
					modifierTag!=null
					?  "It can be customized with the tag " +
						"<tt>@" + CopeFeature.TAG_PREFIX + modifierTag + ' ' +
						Option.TEXT_VISIBILITY_PUBLIC + '|' +
						Option.TEXT_VISIBILITY_PACKAGE + '|' +
						Option.TEXT_VISIBILITY_PROTECTED + '|' +
						Option.TEXT_VISIBILITY_PRIVATE + '|' +
						Option.TEXT_NONE + '|' +
						Option.TEXT_NON_FINAL +
						(useIs ? '|' + Option.TEXT_BOOLEAN_AS_IS : "") + "</tt> " +
						"in the comment of the field."
					: null);
			}

			if(wrapper.isMethodDeprecated())
			{
				writeIndent();
				write("@Deprecated");
				write(lineSeparator);
			}

			writeIndent();

			if(option.override)
			{
				write('@');
				write(OVERRIDE);
				write(' ');
			}

			writeModifier(option.getModifier(modifier) | (isStatic ? STATIC : 0));
			write(ctx.write(methodReturnType));
			if(useIs && option.booleanAsIs)
			{
				write(" is");
				write(featureNameCamelCase);
			}
			else
			{
				write(' ');
				if(pattern!=null)
				{
					if(feature.isDefault())
					{
						final String x = format(pattern, "", "");
						if(!isKeyword(x))
							write(x);
						else
							write(format(pattern, featureNameCamelCase, feature.name));
					}
					else
						write(format(pattern, featureNameCamelCase, feature.name));
				}
				else
				{
					if(feature.isDefault() && !isKeyword(methodName))
						write(methodName);
					else
						writeName(methodName, featureNameCamelCase);
				}
			}
			write(option.suffix);
			write('(');
			{
				final CharSeparator comma = new CharSeparator(',');
				for(final WrapperX.Parameter parameter : parameters)
				{
					if(parameter.varargs!=null)
					{
						for(final Object parameterInstanceO : parameter.varargs)
						{
							final Feature parameterInstance = (Feature)parameterInstanceO;
							comma.appendTo(output);
							final JavaField parameterField = javaClass.getFieldByInstance(parameterInstance);
							final CopeFeature parameterFeature = feature.parent.getFeature(parameterField.name);

							write(finalArgPrefix);
							write(new Context(parameterFeature, false).write(parameterFeature.getInitialType()));
							write(' ');
							write(format(parameterField.name, arguments));
						}
					}
					else
					{
						comma.appendTo(output);
						write(finalArgPrefix);
						write(ctx.write(parameter.getType()));
						write(' ');
						write(format(parameter.getName(), arguments));
					}
				}
			}
			write(')');
			write(lineSeparator);
			writeThrowsClause(throwsClause.keySet());
			writeIndent();
			write('{');
			write(lineSeparator);
			writeIndent(1);
			if(!methodReturnType.equals(void.class))
				write("return ");
		if(feature.parent.isComposite)
		{
			write(methodName);
			write('(');
			{
				write(feature.parent.name);
				write('.');
				write(feature.name);
				for(final WrapperX.Parameter parameter : parameters)
				{
					write(',');
					write(format(parameter.getName(), arguments));
				}
			}
			write(')');
		}
		else
		{
			final boolean block = feature.parent.isBlock;
			if(block)
				write("field().of(");
			write(feature.parent.name);
			write('.');
			write(feature.name);
			if(block)
				write(')');
			write('.');
			write(methodName);
			write('(');
			{
				final CharSeparator comma = new CharSeparator(',');
				if(isStatic)
				{
					if(wrapper.hasStaticClassToken())
					{
						comma.appendTo(output);
						write(feature.parent.name);
						write(".class");
					}
				}
				else
				{
					comma.appendTo(output);
					write(block ? "item()" : "this");
				}
				for(final WrapperX.Parameter parameter : parameters)
				{
					if(parameter.varargs!=null)
					{
						for(final Object parameterInstanceO : parameter.varargs)
						{
							final Feature parameterInstance = (Feature)parameterInstanceO;
							comma.appendTo(output);
							write(format(javaClass.getFieldByInstance(parameterInstance).name, arguments));
						}
					}
					else
					{
						comma.appendTo(output);
						write(format(parameter.getName(), arguments));
					}
				}
			}
			write(')');
		}
			write(';');
			write(lineSeparator);
			writeIndent();
			write('}');
		}
	}

	private List<WrapperX> getWrappers(final Feature feature)
	{
		return getWrappers(feature.getClass(), feature);
	}

	private List<WrapperX> getWrappers(final Class<? extends Feature> clazz, final Feature feature)
	{
		return WrapperByAnnotations.make(
				clazz,
				feature,
				((Feature.class.isAssignableFrom(clazz)) && (Feature.class!=clazz))
				? getWrappers(clazz.getSuperclass().asSubclass(Feature.class), feature)
				: Collections.<WrapperX>emptyList());
	}

	private void writeName(final String methodName, final String featureName)
	{
		for(int i = 0; i<methodName.length(); i++)
			if(Character.isUpperCase(methodName.charAt(i)))
			{
				write(methodName.substring(0, i));
				write(featureName);
				write(methodName.substring(i));
				return;
			}

		write(methodName);
		write(featureName);
	}

	private void writeCommentParagraph(
			final String prefix1, final String prefixN,
			final String[] lines,
			final Object[] arguments)
	{
		if(lines.length>0)
		{
			final String line = lines[0];
			writeIndent();
			write(" *");
			if(!prefix1.isEmpty())
			{
				write(' ');
				write(prefix1);
			}
			if(!line.isEmpty())
			{
				write(' ');
				write(format(line, arguments));
			}
			write(lineSeparator);
		}
		for(int i = 1; i<lines.length; i++)
		{
			final String line = lines[i];
			writeIndent();
			write(" *");
			if(!line.isEmpty())
			{
				write(prefixN);
				write(format(line, arguments));
			}
			write(lineSeparator);
		}
	}

	private void writeSerialVersionUID()
	{
		if(serialVersionUID)
		{
			writeCommentHeader();
			writeCommentFooter();

			writeIndent();
			writeModifier(PRIVATE|STATIC|FINAL);
			write("long serialVersionUID = 1l;");
		}
	}

	private void writeType(final CopeType type)
	{
		if(type.isComposite)
			return;

		final Option option = type.typeOption;
		if(option.exists)
		{
			final boolean block = type.isBlock;

			writeCommentHeader();
			writeIndent();
			write(" * ");
			write(format(block ? TYPE_BLOCK : TYPE, lowerCamelCase(type.name)));
			write(lineSeparator);
			writeCommentFooter(TYPE_CUSTOMIZE);

			if(hidingWarningSuppressor!=null && type.getSuperclass()!=null)
			{
				writeIndent();
				write("@SuppressWarnings(\"hiding\")");
				write(lineSeparator);
			}

			writeIndent();
			writeModifier(option.getModifier(type.javaClass.modifier) | (STATIC|FINAL));
			write(block ? BLOCK_TYPE_NAME : TYPE_NAME);
			write('<');
			write(type.name);
			write("> TYPE = ");
			write(block ? BLOCK_TYPE_NAME : TYPES_BOUND_NAME);
			write(".newType(");
			write(type.name);
			write(".class);");
		}
	}

	void write() throws ParserException
	{
		final String buffer = javaFile.buffer.toString();
		int previousClassEndPosition = 0;
		for(final JavaClass javaClass : javaFile.getClasses())
		{
			final CopeType type = CopeType.getCopeType(javaClass);
			final int classEndPosition = javaClass.getClassEndPosition();
			if(type!=null)
			{
				assert previousClassEndPosition<=classEndPosition;
				if(previousClassEndPosition<classEndPosition)
					output.append(buffer, previousClassEndPosition, classEndPosition);

				try
				{
					typeIndent = type.indent;
					writeClassFeatures(type);
					typeIndent = Integer.MIN_VALUE;
				}
				catch (final RuntimeException e)
				{
					throw new RuntimeException("Failed to generate class features for " + javaClass, e);
				}
				previousClassEndPosition = classEndPosition;
			}
		}
		output.append(buffer, previousClassEndPosition, buffer.length());
	}

	private void writeClassFeatures(final CopeType type)
			throws ParserException
	{
		if(!type.isInterface())
		{
			writeInitialConstructor(type);
			writeGenericConstructor(type);

			for(final CopeFeature feature : type.getFeatures())
				writeFeature(feature);

			writeSerialVersionUID();
			writeType(type);
			writeActivationConstructor(type);
		}
	}

	private void writeModifier(final int modifier)
	{
		final String modifierString = Modifier.toString(modifier);
		if(!modifierString.isEmpty())
		{
			write(modifierString);
			write(' ');
		}
	}

	private static boolean isKeyword(final String s)
	{
		return "for".equals(s); // TODO
	}

	private void writeIndent()
	{
		assert typeIndent>=0 : typeIndent;
		writeIndentInternal(typeIndent);
	}

	private void writeIndent(final int additionalLevel)
	{
		assert typeIndent>=0 : typeIndent;
		writeIndentInternal(typeIndent + additionalLevel);
	}

	private void writeIndentInternal(final int level)
	{
		for(int i = 0; i<level; i++)
			output.append('\t');
	}

	private void write(final String s)
	{
		output.append(s);
	}

	private void write(final char c)
	{
		output.append(c);
	}
}

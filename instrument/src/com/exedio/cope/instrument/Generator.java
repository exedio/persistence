/*
 * Copyright (C) 2004-2009  exedio GmbH (www.exedio.com)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package com.exedio.cope.instrument;

import static java.lang.reflect.Modifier.FINAL;
import static java.lang.reflect.Modifier.PRIVATE;
import static java.lang.reflect.Modifier.PROTECTED;
import static java.lang.reflect.Modifier.PUBLIC;
import static java.lang.reflect.Modifier.STATIC;
import static java.text.MessageFormat.format;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.SortedSet;
import java.util.zip.CRC32;
import java.util.zip.CheckedOutputStream;

import com.exedio.cope.ActivationParameters;
import com.exedio.cope.BooleanField;
import com.exedio.cope.Feature;
import com.exedio.cope.Item;
import com.exedio.cope.SetValue;
import com.exedio.cope.Settable;
import com.exedio.cope.Type;

final class Generator
{
	private static final String SET_VALUE = SetValue.class.getName();
	private static final String ITEM = Item.class.getName();
	private static final String TYPE_NAME = Type.class.getName();
	private static final String ACTIVATION = ActivationParameters.class.getName();
	
	private static final String CONSTRUCTOR_INITIAL = "Creates a new {0} with all the fields initially needed.";
	private static final String CONSTRUCTOR_INITIAL_PARAMETER = "the initial value for field {0}.";
	private static final String CONSTRUCTOR_INITIAL_CUSTOMIZE = "It can be customized with the tags " +
																					"<tt>@" + CopeType.TAG_INITIAL_CONSTRUCTOR + ' ' +
																					Option.TEXT_VISIBILITY_PUBLIC + '|' +
																					Option.TEXT_VISIBILITY_PACKAGE + '|' +
																					Option.TEXT_VISIBILITY_PROTECTED + '|' +
																					Option.TEXT_VISIBILITY_PRIVATE + '|' +
																					Option.TEXT_NONE +
																					"</tt> " +
																					"in the class comment and " +
																					"<tt>@" + CopeFeature.TAG_INITIAL + "</tt> in the comment of fields.";
	private static final String CONSTRUCTOR_GENERIC = "Creates a new {0} and sets the given fields initially.";
	private static final String CONSTRUCTOR_GENERIC_CALLED = "This constructor is called by {0}.";
	private static final String CONSTRUCTOR_GENERIC_CUSTOMIZE = "It can be customized with the tag " +
																					"<tt>@" + CopeType.TAG_GENERIC_CONSTRUCTOR + ' ' +
																					Option.TEXT_VISIBILITY_PUBLIC + '|' +
																					Option.TEXT_VISIBILITY_PACKAGE + '|' +
																					Option.TEXT_VISIBILITY_PROTECTED + '|' +
																					Option.TEXT_VISIBILITY_PRIVATE + '|' +
																					Option.TEXT_NONE +
																					"</tt> " +
																					"in the class comment.";
	private static final String CONSTRUCTOR_ACTIVATION = "Activation constructor. Used for internal purposes only.";
	private static final String FINDER_UNIQUE = "Finds a {0} by it''s unique fields.";
	private static final String FINDER_UNIQUE_PARAMETER = "shall be equal to field {0}.";
	private static final String FINDER_UNIQUE_RETURN = "null if there is no matching item.";
	private static final String TYPE = "The persistent type information for {0}.";
	private static final String TYPE_CUSTOMIZE = "It can be customized with the tag " +
																"<tt>@" + CopeType.TAG_TYPE + ' ' +
																Option.TEXT_VISIBILITY_PUBLIC + '|' +
																Option.TEXT_VISIBILITY_PACKAGE + '|' +
																Option.TEXT_VISIBILITY_PROTECTED + '|' +
																Option.TEXT_VISIBILITY_PRIVATE + '|' +
																Option.TEXT_NONE +
																"</tt> " +
																"in the class comment.";
	private static final String GENERATED = "This feature has been generated by the cope instrumentor and will be overwritten by the build process.";

	/**
	 * All generated class features get this doccomment tag.
	 */
	static final String TAG_GENERATED = CopeFeature.TAG_PREFIX + "generated";
	

	private final JavaFile javaFile;
	private final Writer o;
	private final CRC32 outputCRC = new CRC32();
	private final String lineSeparator;
	private final boolean longJavadoc;
	private final String finalArgPrefix;
	private final boolean serialVersionUID;
	private final boolean skipDeprecated;
	
	
	Generator(final JavaFile javaFile, final ByteArrayOutputStream outputStream, final Params params)
	{
		this.javaFile = javaFile;
		this.o = new OutputStreamWriter(new CheckedOutputStream(outputStream, outputCRC));
		
		final String systemLineSeparator = System.getProperty("line.separator");
		if(systemLineSeparator==null)
		{
			System.out.println("warning: property \"line.separator\" is null, using LF (unix style).");
			lineSeparator = "\n";
		}
		else
			lineSeparator = systemLineSeparator;
		
		this.longJavadoc = params.longJavadoc;
		this.finalArgPrefix = params.finalArgs ? "final " : "";
		this.serialVersionUID = params.serialVersionUID;
		this.skipDeprecated = !params.createDeprecated;
	}
	
	void close() throws IOException
	{
		if(o!=null)
			o.close();
	}
	
	long getCRC()
	{
		return outputCRC.getValue();
	}

	private static final String toCamelCase(final String name)
	{
		final char first = name.charAt(0);
		if (Character.isUpperCase(first))
			return name;
		else
			return Character.toUpperCase(first) + name.substring(1);
	}

	private static final String lowerCamelCase(final String s)
	{
		final char first = s.charAt(0);
		if(Character.isLowerCase(first))
			return s;
		else
			return Character.toLowerCase(first) + s.substring(1);
	}
	
	private void writeThrowsClause(final Collection<Class<? extends Throwable>> exceptions)
	throws IOException
	{
		if(!exceptions.isEmpty())
		{
			o.write("\t\t\tthrows");
			boolean first = true;
			for(final Class e : exceptions)
			{
				if(first)
					first = false;
				else
					o.write(',');
				o.write(lineSeparator);
				o.write("\t\t\t\t");
				o.write(e.getName());
			}
			o.write(lineSeparator);
		}
	}

	private void writeCommentHeader()
	throws IOException
	{
		o.write("/**");
		o.write(lineSeparator);
		if(longJavadoc)
		{
			o.write(lineSeparator);
			o.write("\t **");
			o.write(lineSeparator);
		}
	}

	private void writeCommentFooter()
	throws IOException
	{
		writeCommentFooter(null);
	}
	
	private void writeCommentFooter(final String extraComment)
	throws IOException
	{
		o.write("\t * @" + TAG_GENERATED + ' ');
		o.write(GENERATED);
		o.write(lineSeparator);
		if(extraComment!=null)
		{
			o.write("\t *       ");
			o.write(extraComment);
			o.write(lineSeparator);
		}
		o.write("\t */");
		o.write(lineSeparator);
	}
	
	private static final String link(final String target)
	{
		return "{@link #" + target + '}';
	}

	private void writeInitialConstructor(final CopeType type)
	throws IOException
	{
		if(!type.hasInitialConstructor())
			return;

		final List<CopeFeature> initialFeatures = type.getInitialFeatures();
		final SortedSet<Class<? extends Throwable>> constructorExceptions = type.getConstructorExceptions();
		
		writeCommentHeader();
		o.write("\t * ");
		o.write(format(CONSTRUCTOR_INITIAL, type.name));
		o.write(lineSeparator);
		for(final CopeFeature feature : initialFeatures)
		{
			o.write("\t * @param ");
			o.write(feature.name);
			o.write(' ');
			o.write(format(CONSTRUCTOR_INITIAL_PARAMETER, link(feature.name)));
			o.write(lineSeparator);
		}
		for(final Class<?> constructorException : constructorExceptions)
		{
			final ConstructorComment a = constructorException.getAnnotation(ConstructorComment.class);
			if(a==null)
				continue;
			
			o.write("\t * @throws ");
			o.write(constructorException.getName());
			o.write(' ');

			boolean first = true;
			final StringBuilder initialAttributesBuf = new StringBuilder();
			for(final CopeFeature feature : initialFeatures)
			{
				if(!feature.getInitialExceptions().contains(constructorException))
					continue;

				if(first)
					first = false;
				else
					initialAttributesBuf.append(", ");
				initialAttributesBuf.append(feature.name);
			}

			final String pattern = a.value();
			o.write(format(pattern, initialAttributesBuf.toString()));
			o.write(lineSeparator);
		}
		writeCommentFooter(CONSTRUCTOR_INITIAL_CUSTOMIZE);
		
		o.write('\t');
		writeModifier(type.getInitialConstructorModifier());
		o.write(type.name);
		o.write('(');
		
		boolean first = true;
		for(final CopeFeature feature : initialFeatures)
		{
			if(first)
				first = false;
			else
				o.write(',');
			
			o.write(lineSeparator);
			o.write("\t\t\t\t");
			o.write(finalArgPrefix);
			o.write(toString(((Settable<?>)feature.getInstance()).getInitialType(), feature));
			o.write(' ');
			o.write(feature.name);
		}
		
		o.write(')');
		o.write(lineSeparator);
		writeThrowsClause(constructorExceptions);
		o.write("\t{");
		o.write(lineSeparator);
		o.write("\t\tthis(new " + SET_VALUE + "[]{");
		o.write(lineSeparator);
		for(final CopeFeature feature : initialFeatures)
		{
			o.write("\t\t\t");
			o.write(type.name);
			o.write('.');
			o.write(feature.name);
			o.write(".map(");
			o.write(feature.name);
			o.write("),");
			o.write(lineSeparator);
		}
		o.write("\t\t});");
		o.write(lineSeparator);
		o.write("\t}");
	}
	
	private void writeGenericConstructor(final CopeType type)
	throws IOException
	{
		final Option option = type.genericConstructorOption;
		if(!option.exists)
			return;

		writeCommentHeader();
		o.write("\t * ");
		o.write(format(CONSTRUCTOR_GENERIC, type.name));
		o.write(lineSeparator);
		o.write("\t * ");
		o.write(format(CONSTRUCTOR_GENERIC_CALLED, "{@link " + TYPE_NAME + "#newItem Type.newItem}"));
		o.write(lineSeparator);
		writeCommentFooter(CONSTRUCTOR_GENERIC_CUSTOMIZE);
		
		o.write('\t');
		writeModifier(option.getModifier(type.allowSubtypes() ? PROTECTED : PRIVATE));
		o.write(type.name);
		o.write('(');
		o.write(finalArgPrefix);
		o.write(SET_VALUE + "... setValues)");
		o.write(lineSeparator);
		o.write("\t{");
		o.write(lineSeparator);
		o.write("\t\tsuper(setValues);");
		o.write(lineSeparator);
		o.write("\t}");
	}
	
	private void writeActivationConstructor(final CopeType type)
	throws IOException
	{
		final Option option = type.activationConstructorOption;
		if(!option.exists)
			return;

		writeCommentHeader();
		o.write("\t * ");
		o.write(CONSTRUCTOR_ACTIVATION);
		o.write(lineSeparator);
		o.write("\t * @see " + ITEM + "#Item(" + ACTIVATION + ")");
		o.write(lineSeparator);
		writeCommentFooter();
		
		final boolean allowSubtypes = type.allowSubtypes();
		o.write('\t');
		if(!allowSubtypes)
			o.write("@SuppressWarnings(\"unused\") ");
		writeModifier(option.getModifier(allowSubtypes ? PROTECTED : PRIVATE));
		o.write(type.name);
		o.write('(');
		o.write(finalArgPrefix);
		o.write(ACTIVATION + " ap)");
		o.write(lineSeparator);
		o.write("\t{");
		o.write(lineSeparator);
		o.write("\t\tsuper(ap);");
		o.write(lineSeparator);
		o.write("\t}");
	}
	
	private void writeFeature(final CopeFeature feature)
	throws InjectorParseException, IOException
	{
		final Feature instance = feature.getInstance();
		for(final Wrapper wrapper : instance.getWrappers())
		{
			final boolean deprecated = wrapper.isDeprecated();
			if(deprecated && skipDeprecated)
				continue;
			
			final String pattern = wrapper.getMethodWrapperPattern();
			final String modifierTag = pattern!=null ? format(pattern, "", "") : wrapper.getName();
			final Option option =
				modifierTag!=null
				? new Option(Injector.findDocTagLine(
									feature.docComment,
									CopeFeature.TAG_PREFIX + modifierTag),
						true)
				: null;
			
			if(option!=null && !option.exists)
				continue;

			final String methodName = wrapper.getName();
			final java.lang.reflect.Type methodReturnType = wrapper.getReturnType();
			final List<Wrapper.Parameter> parameters = wrapper.getParameters();
			final Map<Class<? extends Throwable>, String> throwsClause = wrapper.getThrowsClause();
			final String featureNameCamelCase = toCamelCase(feature.name);
			final boolean isStatic = wrapper.isStatic();
			final int modifier = feature.modifier;
			final boolean useIs = instance instanceof BooleanField && methodName.startsWith("get");
			
			final Object[] arguments = new String[]{
					link(feature.name),
					feature.name,
					lowerCamelCase(feature.parent.name)};
			{
				writeCommentHeader();
				for(final String comment : wrapper.getComments())
				{
					o.write("\t * ");
					o.write(format(comment, arguments));
					o.write(lineSeparator);
				}
				for(final Wrapper.Parameter parameter : wrapper.getParameters())
				{
					final String comment = parameter.getComment();
					if(comment!=null)
					{
						o.write("\t * @param ");
						o.write(format(parameter.getName(), arguments));
						o.write(' ');
						o.write(format(comment, arguments));
						o.write(lineSeparator);
					}
				}
				{
					final String comment = wrapper.getReturnComment();
					if(comment!=null)
					{
						o.write("\t * @return ");
						o.write(format(comment, arguments));
						o.write(lineSeparator);
					}
				}
				for(final Map.Entry<Class<? extends Throwable>, String> e : throwsClause.entrySet())
				{
					final String comment = e.getValue();
					if(comment!=null)
					{
						o.write("\t * @throws ");
						o.write(e.getKey().getName());
						o.write(' ');
						o.write(format(comment, arguments));
						o.write(lineSeparator);
					}
				}
				if(deprecated)
				{
					o.write("\t * @deprecated ");
					o.write(format(wrapper.getDeprecationComment(), arguments));
					o.write(lineSeparator);
				}
				writeCommentFooter(
					modifierTag!=null
					?  "It can be customized with the tag " +
						"<tt>@" + CopeFeature.TAG_PREFIX + modifierTag + ' ' +
						Option.TEXT_VISIBILITY_PUBLIC + '|' +
						Option.TEXT_VISIBILITY_PACKAGE + '|' +
						Option.TEXT_VISIBILITY_PROTECTED + '|' +
						Option.TEXT_VISIBILITY_PRIVATE + '|' +
						Option.TEXT_NONE + '|' +
						Option.TEXT_NON_FINAL +
						(useIs ? '|' + Option.TEXT_BOOLEAN_AS_IS : "") + "</tt> " +
						"in the comment of the field."
					: null);
			}
			
			if(deprecated)
			{
				o.write('\t');
				o.write("@Deprecated");
				o.write(lineSeparator);
			}
			
			o.write('\t');
			writeModifier(
				(
					option!=null
					? option.getModifier(modifier)
					: ((modifier & (PUBLIC|PROTECTED|PRIVATE)) | FINAL)
				)
				|
				(isStatic ? STATIC : 0)
			);
			o.write(toString(methodReturnType, feature));
			if(option!=null && useIs && option.booleanAsIs)
			{
				o.write(" is");
				o.write(featureNameCamelCase);
			}
			else
			{
				o.write(' ');
				if(pattern!=null)
					o.write(format(pattern, featureNameCamelCase, feature.name));
				else
					writeName(methodName, featureNameCamelCase);
			}
			if(option!=null)
				o.write(option.suffix);
			o.write('(');
			{
				boolean first = true;
				for(final Wrapper.Parameter parameter : parameters)
				{
					if(first)
						first = false;
					else
						o.write(',');
					
					o.write(finalArgPrefix);
					o.write(toString(parameter.getType(), feature));
					o.write(' ');
					o.write(format(parameter.getName(), arguments));
				}
			}
			o.write(')');
			o.write(lineSeparator);
			writeThrowsClause(throwsClause.keySet());
			o.write("\t{");
			o.write(lineSeparator);
			o.write("\t\t");
			if(!methodReturnType.equals(void.class))
				o.write("return ");
			o.write(feature.parent.name);
			o.write('.');
			o.write(feature.name);
			o.write('.');
			o.write(methodName);
			o.write('(');
			{
				boolean first = true;
				if(isStatic)
				{
					if(first)
						first = false;
					else
						o.write(',');
					
					o.write(feature.parent.name);
					o.write(".class");
				}
				else
				{
					first = false;
					o.write("this");
				}
				for(final Wrapper.Parameter parameter : parameters)
				{
					if(first)
						first = false;
					else
						o.write(',');
					
					o.write(format(parameter.getName(), arguments));
				}
			}
			o.write(')');
			o.write(';');
			o.write(lineSeparator);
			o.write("\t}");
		}
	}
	
	private void writeName(final String methodName, final String featureName) throws IOException
	{
		for(int i = 0; i<methodName.length(); i++)
			if(Character.isUpperCase(methodName.charAt(i)))
			{
				o.write(methodName.substring(0, i));
				o.write(featureName);
				o.write(methodName.substring(i));
				return;
			}
		
		o.write(methodName);
		o.write(featureName);
	}
	
	private static final String toString(final Class c, final CopeFeature feature)
	{
		if(Wrapper.ClassVariable.class.equals(c))
			return feature.parent.name;
		else if(Wrapper.TypeVariable0.class.equals(c))
			return toStringType(feature, 0);
		else if(Wrapper.TypeVariable1.class.equals(c))
			return toStringType(feature, 1);
		else
			return c.getCanonicalName();
	}
	
	private static final String toStringType(final CopeFeature feature, final int number)
	{
		return Injector.getGenerics(feature.javaAttribute.type).get(number);
	}
	
	private static final String toString(final ParameterizedType t, final CopeFeature feature)
	{
		final StringBuilder bf = new StringBuilder(toString(t.getRawType(), feature));
		bf.append('<');
		boolean first = true;
		for(final java.lang.reflect.Type a : t.getActualTypeArguments())
		{
			bf.append(toString(a, feature));
			
			if(first)
				first = false;
			else
				bf.append(',');
		}
		bf.append('>');
		
		return bf.toString();
	}
	
	private static final String toString(final Wrapper.ExtendsType t, final CopeFeature feature)
	{
		final StringBuilder bf = new StringBuilder(toString(t.getRawType(), feature));
		bf.append('<');
		boolean first = true;
		for(final java.lang.reflect.Type a : t.getActualTypeArguments())
		{
			bf.append("? extends ");
			bf.append(toString(a, feature));
			
			if(first)
				first = false;
			else
				bf.append(',');
		}
		bf.append('>');
		
		return bf.toString();
	}
	
	private static final String toString(final java.lang.reflect.Type t, final CopeFeature feature)
	{
		if(t instanceof Class)
			return toString((Class)t, feature);
		else if(t instanceof ParameterizedType)
			return toString((ParameterizedType)t, feature);
		else if(t instanceof Wrapper.ExtendsType)
			return toString((Wrapper.ExtendsType)t, feature);
		else
			throw new RuntimeException(t.toString());
	}
	
	private void writeUniqueFinder(final CopeUniqueConstraint constraint, final boolean deprecated)
	throws IOException, InjectorParseException
	{
		final Option option = new Option(
				Injector.findDocTagLine(constraint.docComment, CopeFeature.TAG_PREFIX + "finder"), true);
		if(option!=null && !option.exists)
			return;
		
		final CopeAttribute[] attributes = constraint.getAttributes();
		final String className = attributes[0].getParent().name;
		
		writeCommentHeader();
		o.write("\t * ");
		o.write(format(FINDER_UNIQUE, lowerCamelCase(className)));
		o.write(lineSeparator);
		if(deprecated)
		{
			o.write("\t * @deprecated use for");
			o.write(toCamelCase(constraint.name));
			o.write(" instead.");
			o.write(lineSeparator);
		}
		for(int i=0; i<attributes.length; i++)
		{
			o.write("\t * @param ");
			o.write(attributes[i].name);
			o.write(' ');
			o.write(format(FINDER_UNIQUE_PARAMETER, link(attributes[i].name)));
			o.write(lineSeparator);
		}
		o.write("\t * @return ");
		o.write(FINDER_UNIQUE_RETURN);
		o.write(lineSeparator);

		writeCommentFooter();
		
		if(deprecated)
		{
			o.write('\t');
			o.write("@Deprecated");
			o.write(lineSeparator);
		}
		
		o.write('\t');
		writeModifier((option!=null ? option.getModifier(constraint.modifier) : (constraint.modifier&(PRIVATE|PROTECTED|PUBLIC))) | (STATIC|FINAL) );
		o.write(className);
		o.write(deprecated ? " findBy" : " for");
		o.write(toCamelCase(constraint.name));
		
		o.write('(');
		for(int i=0; i<attributes.length; i++)
		{
			if(i>0)
				o.write(',');
			final CopeAttribute attribute = attributes[i];
			o.write(finalArgPrefix);
			o.write(getBoxedType(attribute));
			o.write(' ');
			o.write(attribute.name);
		}
		o.write(')');
		o.write(lineSeparator);
		o.write("\t{");
		o.write(lineSeparator);
		o.write("\t\treturn ");

		o.write(attributes[0].parent.name);
		o.write('.');
		o.write(constraint.name);
		o.write(".search(");
		o.write(className);
		o.write(".class,");
		o.write(attributes[0].name);
		for(int i = 1; i<attributes.length; i++)
		{
			o.write(',');
			o.write(attributes[i].name);
		}
		o.write(");");
		o.write(lineSeparator);
		o.write("\t}");
	}
	
	@SuppressWarnings("deprecation")
	private String getBoxedType(final CopeAttribute a)
	{
		return a.getBoxedType();
	}
	
	private void writeSerialVersionUID() throws IOException
	{
		if(serialVersionUID)
		{
			writeCommentHeader();
			writeCommentFooter();
			
			o.write('\t');
			writeModifier(PRIVATE|STATIC|FINAL);
			o.write("long serialVersionUID = 1l;");
		}
	}
	
	private void writeType(final CopeType type)
	throws IOException
	{
		final Option option = type.typeOption;
		if(option.exists)
		{
			writeCommentHeader();
			o.write("\t * ");
			o.write(format(TYPE, lowerCamelCase(type.name)));
			o.write(lineSeparator);
			writeCommentFooter(TYPE_CUSTOMIZE);
			
			o.write('\t');
			writeModifier(option.getModifier(type.javaClass.modifier) | (STATIC|FINAL));
			o.write(TYPE_NAME + '<');
			o.write(type.name);
			o.write("> TYPE = newType(");
			o.write(type.name);
			o.write(".class)");
			o.write(lineSeparator);
	
			o.write(';');
		}
	}
	
	void write() throws IOException, InjectorParseException
	{
		final String buffer = javaFile.buffer.toString();
		int previousClassEndPosition = 0;
		for(final JavaClass javaClass : javaFile.getClasses())
		{
			final CopeType type = CopeType.getCopeType(javaClass);
			final int classEndPosition = javaClass.getClassEndPosition();
			if(type!=null)
			{
				assert previousClassEndPosition<=classEndPosition;
				if(previousClassEndPosition<classEndPosition)
					o.write(buffer, previousClassEndPosition, classEndPosition-previousClassEndPosition);

				writeClassFeatures(type);
				previousClassEndPosition = classEndPosition;
			}
		}
		o.write(buffer, previousClassEndPosition, buffer.length()-previousClassEndPosition);
	}

	private void writeClassFeatures(final CopeType type)
			throws IOException, InjectorParseException
	{
		if(!type.isInterface())
		{
			writeInitialConstructor(type);
			writeGenericConstructor(type);
			writeActivationConstructor(type);
			
			for(final CopeFeature feature : type.getFeatures())
			{
				writeFeature(feature);
				if(feature instanceof CopeUniqueConstraint)
				{
					writeUniqueFinder((CopeUniqueConstraint)feature, false);
					if(!skipDeprecated)
						writeUniqueFinder((CopeUniqueConstraint)feature, true);
				}
			}
			
			writeSerialVersionUID();
			writeType(type);
		}
	}

	private void writeModifier(final int modifier) throws IOException
	{
		final String modifierString = Modifier.toString(modifier);
		if(modifierString.length()>0)
		{
			o.write(modifierString);
			o.write(' ');
		}
	}
}

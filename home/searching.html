<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>COPE - Searching Trail</title>
		<meta name="keywords" content="Persistence, Java">
		<meta name="description" content="COPE - a persistence framework for Java">
		<link rel="stylesheet" href="cope.css">
	</head>
	<body>
		<a href="http://www.exedio.com/">
			<img src="exedio.png" class="exedio">
		</a>
		<h1><a href="index.html">COPE</a></h1>
		<div>Cope with Object Persistence</div>
		
		<h2>Searching Trail</h2>
		<a href="http://sourceforge.net/">
			<img src="http://sourceforge.net/sflogo.php?group_id=152867&amp;type=1"
				class="sf" alt="SourceForge.net Logo" />
		</a>
		<div>
			This trail shows you how to query your data with COPE.
			If you are familiar with SQL,
			you will recognize it's features within the syntax of COPE queries.
			However, you will never directly write SQL,
			nor any other text based query language.
			This will show you most common mistakes as compile-time errors,
			and it will completely remove any chance of
			<a href="http://en.wikipedia.org/wiki/SQL_injection">SQL injection</a>.
		</div>
		<h3><a name="contents">Contents</a></h3>
		<ul>
			<li><a href="#simple">Simple Query</a></li>
			<li><a href="#conditions">Conditions</a></li>
			<li><a href="#sorting">Sorting</a></li>
			<li><a href="#limits">Limits</a></li>
			<li><a href="#selecting">Selecting and Aggregating</a></li>
			<li><a href="#joins">Joins</a></li>
			<li><a href="#further">Further Reading</a></li>
		</ul>
		<h3><a name="simple">Simple Query</a></h3>
		<div>
			First we define a simple example model
			consisting of one persistent class only:
		</div>
<pre>
class Customer extends <a href="api/com/exedio/cope/Item.html">Item</a>
{
   static final <a href="api/com/exedio/cope/StringField.html">StringField</a> email =
       new <a href="api/com/exedio/cope/StringField.html#StringField()">StringField</a>();
   static final <a href="api/com/exedio/cope/IntegerField.html">IntegerField</a> loginCounter =
       new <a href="api/com/exedio/cope/IntegerField.html#IntegerField()">IntegerField</a>();
}
</pre>
		<div>
			Lets start with a simple query searching for all instances of
			this class:
		</div>
<pre>
List&lt;Customer&gt; allCustomers =
   Customer.TYPE.<a href="api/com/exedio/cope/Type.html#search()">search</a>();
</pre>
		<div>
			Note, that the static final field <tt>Customer.TYPE</tt> is
			generated by the cope instrumentor.
			Compiling this statement does not cause an "unchecked warning",
			the return type of search is really a <tt>List&lt;Customer&gt;</tt>
		</div>
		<div>
			If you put the code above into class <tt>Customer</tt>,
			you can write even shorter:
		</div>
<pre>
List&lt;Customer&gt; allCustomers = TYPE.<a href="api/com/exedio/cope/Type.html#search()">search</a>();
</pre>
		<div>
			For brevity we will assume, that all the examples below are
			located in class <tt>Customer</tt>.
		</div>
		<h3><a name="conditions">Conditions</a></h3>
		<div>
			Conditions restrict the number of items found by a query.
			This is equivalent to the "where clause" in SQL.
			Lets search for the customer with a certain email address:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(email.<a href="api/com/exedio/cope/Function.html#equal(E)">equal</a>("cope@exedio.com"));
</pre>
		<div>
			For a "like condition" write:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(email.<a href="api/com/exedio/cope/StringFunction.html#like(java.lang.String)"><b>like</b></a>("cope@exedio.<b>%</b>"));
</pre>
		<div>
			There is a convenience method, that lets you write equivalently but shorter:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(email.<a href="api/com/exedio/cope/StringFunction.html#startsWith(java.lang.String)"><b>startsWith</b></a>("cope@exedio."));
</pre>
		<div>
			Of course searching works for integer fields as well.
			Here a query, that searches for customers,
			that have logged in at least 8 times:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(loginCounter.<a href="api/com/exedio/cope/Function.html#greaterOrEqual(E)">greaterOrEqual</a>(8));
</pre>
		<div>
			To demonstrate composite conditions,
			here another query, that searches for customers,
			that have logged in at least 8 times, but at most 12 times:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(loginCounter.<a href="api/com/exedio/cope/Function.html#greaterOrEqual(E)">greaterOrEqual</a>(8).<a href="api/com/exedio/cope/Condition.html#and(com.exedio.cope.Condition)"><b>and</b></a>(loginCounter.<a href="api/com/exedio/cope/Function.html#lessOrEqual(E)">lessOrEqual</a>(12)));
</pre>
		<div>
			which is equivalent to:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(loginCounter.<a href="api/com/exedio/cope/Function.html#between(E, E)">between</a>(8, 12));
</pre>
		<div>
			Of course there is an OR-condition as well:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(email.<a href="api/com/exedio/cope/Function.html#equal(E)">equal</a>("cope@exedio.com").<a href="api/com/exedio/cope/Condition.html#or(com.exedio.cope.Condition)"><b>or</b></a>(email.<a href="api/com/exedio/cope/Function.html#equal(E)">equal</a>("cope@exedio.de")));
</pre>
		<div>
			which is equivalent to:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(email.<a href="api/com/exedio/cope/Function.html#in(E...)">in</a>("cope@exedio.com", "cope@exedio.de"));
</pre>
		<div>
			In contrast to the queries above,
			all the following queries will not compile:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(email.equal(8));
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(loginCounter.greaterOrEqual("cope@exedio.com"));
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition)">search</a>(loginCounter.like("cope@exedio.%"));
</pre>
		<div>
			The first one tries to compare a string field to an integer literal.
			The second query compares an integer field to a string field.
			The third uses the operator "like" on an integer field instead of a string field.
		</div>
		<h3><a name="sorting">Sorting</a></h3>
		<div>
		<div>
			Here again a query, that searches for customers,
			that have logged in more than 8 times,
			but now sorted by their email adresses:
		</div>
<pre>
TYPE.<a href="api/com/exedio/cope/Type.html#search(com.exedio.cope.Condition, com.exedio.cope.Function, boolean)">search</a>(loginCounter.<a href="api/com/exedio/cope/Function.html#greaterOrEqual(E)">greaterOrEqual</a>(8), <b>email, true</b>);
</pre>
		<div>
			The third parameter specifies accending order.
			Use <tt>false</tt> to order descendingly.
		</div>
		<div>
			If you want to order by multiple fields,
			you have to use an explicit query for the first time.
			This looks like this:
		</div>
<pre>
Query&lt;Customer&gt; q =
   TYPE.newQuery(loginCounter.<a href="api/com/exedio/cope/Function.html#greaterOrEqual(E)">greaterOrEqual</a>(8));
q.addOrderBy(loginCounter);
q.addOrderByDescending(email);
List&lt;Customer&gt; customers = q.search();
</pre>
		<div>
			This query finds all customers,
			which have logged in at least 8 times,
			sorted by the number of their logins ascendingly
			and their email adress descendingly.
		<div>
			Note, that all the methods <tt>Type.search(...)</tt> in the examples before
			use an instance of <tt>Query</tt> in their implementation as well.
			They are convenience methods for the most common and simple queries.
		</div>
		<h3><a name="limits">Limits</a></h3>
		<div>
			Sometimes you want to fetch just a part of the result of a query.
			This is commonly needed for paging.
			The following query gets the third page of a list of all customers,
			which have logged in at least 8 times.
			Each page contains 10 customers:
		</div>
<pre>
Query&lt;Customer&gt; q =
   TYPE.newQuery(loginCounter.<a href="api/com/exedio/cope/Function.html#greaterOrEqual(E)">greaterOrEqual</a>(8));
q.setLimit(20, 10);
List&lt;Customer&gt; customers = q.search();
</pre>
		<div>
			Sometimes you may just want to have the first element of the result.
			Then you would probably write something like this:
		</div>
<pre>
Query&lt;Customer&gt; q =
   TYPE.newQuery(loginCounter.<a href="api/com/exedio/cope/Function.html#greaterOrEqual(E)">greaterOrEqual</a>(8));
q.setLimit(0, 1);
List&lt;Customer&gt; customers = q.search();
</pre>
		<div>
			After such a one-line-only query,
			there often some code like this:
		</div>
<pre>
if(customers.size()==0)
   return null;
else if(customers.size()==1)
   return customers.get(0);
else
   throw new RuntimeException("oops");
</pre>
		<div>
			There is a convenience method <a href="api/com/exedio/cope/Query.html#searchSingleton()">searchSingleton</a>,
			which avoids writing such code over and over again:
		</div>
<pre>
Query&lt;Customer&gt; q =
   TYPE.newQuery(loginCounter.<a href="api/com/exedio/cope/Function.html#greaterOrEqual(E)">greaterOrEqual</a>(8));
q.setLimit(0, 1);
return q.<a href="api/com/exedio/cope/Query.html#searchSingleton()">searchSingleton</a>();
</pre>
		<div>
			This method is useful, whenever you are sure,
			that the result set can have at most one element.
			This happens if
			you use limits as above or
			you restrict your query to match a <i>unique</i> field or
			when using <i>aggregators</i> as explained below.
		</div>
		<h3><a name="selecting">Selecting and Aggregating</a></h3>
		<div>
			Sometimes you just want to deal with values of fields, not items.
			For instance you might want to have a list of the email addresses of
			all customers:
		</div>
<pre>
Query&lt;String&gt; q = new Query&lt;String&gt;(email);
List&lt;String&gt; emails = q.search();
</pre>
		<div>
			Of course you can combine this with sorting and limits.
			To get a list of the greatest 10 login counters you could write:
		</div>
<pre>
Query&lt;Integer&gt; q = new Query&lt;Integer&gt;(loginCounter);
q.setOrderBy(loginCounter, true);
q.setLimit(0, 10);
List&lt;Integer&gt; loginCounters = q.search();
</pre>
		<div>
			Or you might want to compute the sum of the login counters
			of all customers.
			This is called aggregating:
		</div>
<pre>
Query&lt;Integer&gt; q =
   new Query&lt;Integer&gt;(loginCounter.<b>sum()</b>);
Integer totalLoginCounters = q.searchSingleton();
</pre>
		<div>
			Aggregates can be used for getting minimum and maximum as well.
			The following example queries the greatest login counter:
		</div>
<pre>
Query&lt;Integer&gt; q =
   new Query&lt;Integer&gt;(loginCounter.<b>max()</b>);
Integer maximumLoginCounter = q.searchSingleton();
</pre>
		<h3><a name="joins">Joins</a></h3>
		<div>
			To demonstrate joins with COPE,
			we have to define another persistent class:
		</div>
<pre>
class Order extends <a href="api/com/exedio/cope/Item.html">Item</a>
{
   static final <a href="api/com/exedio/cope/ItemField.html">ItemField</a>&lt;Customer&gt; buyer =
       <a href="api/com/exedio/cope/Item.html#newItemField(java.lang.Class)">newItemField</a>(Customer.class);
   static final <a href="api/com/exedio/cope/DoubleField.html">DoubleField</a> total =
       new <a href="api/com/exedio/cope/DoubleField.html#DoubleField()">DoubleField</a>();
}
</pre>
		<div>
			Now we can use a join to search for all orders,
			where the customer has a email address
			from the .com top level domain:
		</div>
<pre>
Query&lt;Order&gt; q = Order.TYPE.newQuery(Customer.email.endsWith(".com"));
q.join(Order.TYPE, Order.buyer.equal(Customer.TYPE.getThis()));
List&lt;Order&gt; orders = q.search();
</pre>
		<div>
			Note the join condition in the second line,
			it specifies a <i>natural join</i> on the item field <tt>buyer</tt>.
			The join condition can also be specified in a short form,
			using a convenience method:
		</div>
<pre>
q.join(Order.TYPE, Order.buyer.<b>equalTarget()</b>);
</pre>
		<h3><a name="further">Further Reading</a></h3>
		<div>
			This was the searching trail of the cope tour.
			You may now proceed to trails:
			<ul>
				<li>
					<a href="transactions.html">Transactions Trail</a>
					tells you how to use transactions in cope.
				</li>
				<li>
					<a href="fields2.html">Field Reloaded Trail</a>
					covers all the more specific possibilities to store data with cope.
				</li>
				<li>
					<a href="webapplications.html">Web Application Trail</a>
					shows you the little differences when using cope within a web container.
				</li>
			</ul>
		</div>
		<address>
			Copyright &copy; 2004-2007
			<a href="http://www.exedio.com/" target="_top">exedio</a>
			Gesellschaft f&uuml;r Softwareentwicklung mbH.
		</address>
	</body>
</html>

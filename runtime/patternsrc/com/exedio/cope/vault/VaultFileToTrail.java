/*
 * Copyright (C) 2004-2015  exedio GmbH (www.exedio.com)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package com.exedio.cope.vault;

import static java.lang.Integer.parseInt;
import static java.time.ZoneOffset.UTC;

import com.exedio.cope.util.CharSet;
import com.exedio.cope.util.Hex;
import com.exedio.cope.util.Sources;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Locale;

/**
 * You may generate a csv file for importing into the database calling:
 * <pre>
 *    java -cp exedio-cope.jar:exedio-cope-util.jar com.exedio.cope.vault.VaultFileToTrail &lt;root-dir&gt; &gt; vault-trail.csv
 * </pre>
 * You may import the csv on MySQL into a table like this:
 * <pre>
 *    CREATE TABLE VaultFileToTrail (
 *       hash varchar(128) PRIMARY KEY,
 *       length bigint NOT NULL,
 *       start20 varchar(40) NOT NULL,
 *       dateEpoch bigint NOT NULL,
 *       date varchar(128) NOT NULL)
 * </pre>
 * with the command
 * <pre>
 *    LOAD DATA INFILE '/var/lib/mysql-files/vault-trail.csv'
 *      INTO TABLE VaultFileToTrail
 *      FIELDS TERMINATED BY ',' ENCLOSED BY '"'
 *      LINES TERMINATED BY '\n'
 *      IGNORE 4 LINES
 * </pre>
 * You may verify the consistency of the length field with
 * <pre>
 *    SELECT COUNT(*) FROM VaultTrail_default a
 *    JOIN VaultFileToTrail b ON a.hash=b.hash
 *    WHERE a.length&lt;&gt;b.length
 * </pre>
 * To verify the consistency of the start field, change the where clause to
 * <pre>
 *    WHERE HEX(a.start20)&lt;&gt;UPPER(b.start20)
 * </pre>
 */
public final class VaultFileToTrail
{
	public static void main(final String[] args)
	{
		try
		{
			mainInternal(System.out, System.err, args);
		}
		catch(final HumanReadableException e)
		{
			System.err.println("ERROR: " + e.getMessage());
			//noinspection CallToSystemExit
			System.exit(1);
		}
		catch(final IOException e)
		{
			System.err.println("ERROR");
			e.printStackTrace(System.err);
			//noinspection CallToSystemExit
			System.exit(1);
		}
	}

	static void mainInternal(
			final PrintStream out,
			final PrintStream err,
			final String... args)
			throws HumanReadableException, IOException
	{
		if(args.length<1)
			throw new HumanReadableException(
					"root directory must be specified as first parameter");

		main(out, err,
				Paths.get(args[0]),
				args.length>1 ? parseInt(args[1]) : startLimitDefault());
	}

	private static int startLimitDefault()
	{
		return new TrailProperties(Sources.EMPTY).startLimit;
	}

	@SuppressWarnings("ConfusingMainMethod")
	private static void main(
			final PrintStream out,
			final PrintStream err,
			final Path root,
			final int startLimit)
			throws HumanReadableException, IOException
	{
		if(!Files.exists(root))
			throw new HumanReadableException(
					"root directory does not exist: " + root.toAbsolutePath());
		if(!Files.isDirectory(root))
			throw new HumanReadableException(
					"root directory is not a directory: " + root.toAbsolutePath());

		out.println("# Generated by " + VaultFileToTrail.class.getName());
		final String spec = VaultFileToTrail.class.getPackage().getSpecificationVersion();
		if(spec!=null)
			out.println("#   " + spec);
		out.println("#   root=" + root.toAbsolutePath());
		out.println("#   startLimit=" + startLimit);

		final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS", Locale.US);

		Files.walkFileTree(root, new SimpleFileVisitor<>()
		{
			private final ArrayList<String> previousHashes = new ArrayList<>();
			private String directoryHashes = null;
			@Override
			public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs)
			{
				final String filename = dir.getFileName().toString();
				if(directoryHashes==null)
				{
					directoryHashes = "";
					return FileVisitResult.CONTINUE;
				}
				if(CharSet.HEX_LOWER.indexOfNotContains(filename)>=0)
				{
					err.println("Skipping non-hex directory " + dir.toAbsolutePath());
					return FileVisitResult.SKIP_SUBTREE;
				}
				final String newHash = directoryHashes + filename;
				previousHashes.add(directoryHashes);
				directoryHashes = newHash;
				return FileVisitResult.CONTINUE;
			}

			@Override
			public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException
			{
				super.postVisitDirectory(dir, exc); // fails if exc!=null
				directoryHashes = previousHashes.isEmpty() ? null : previousHashes.remove(previousHashes.size()-1);
				return FileVisitResult.CONTINUE;
			}

			@Override
			public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs)
					throws IOException
			{
				if(!Files.isRegularFile(file)) // TODO junit test
				{
					err.println("Skipping non-regular file " + file.toAbsolutePath());
					return FileVisitResult.CONTINUE;
				}

				final String filename = file.getFileName().toString();
				if(CharSet.HEX_LOWER.indexOfNotContains(filename)>=0)
				{
					err.println("Skipping non-hex file " + file.toAbsolutePath());
					return FileVisitResult.CONTINUE;
				}

				final long length = Files.size(file);
				if(length==0)
				{
					err.println("Skipping empty file " + file.toAbsolutePath());
					return FileVisitResult.CONTINUE;
				}

				final byte[] start = new byte[(int)Math.min(length, startLimit)];
				try(var in = Files.newInputStream(file))
				{
					final int result = in.read(start);
					if(result!=start.length)
						throw new IllegalStateException(result + "/" + start.length + '/' + file.toAbsolutePath());
				}

				out.println(
						"\"" + directoryHashes + filename + "\",\"" +
						length + "\",\"" +
						Hex.encodeLower(start) + "\",\"" +
						dateFormatter.format(LocalDateTime.ofInstant(Files.getLastModifiedTime(file).toInstant(), UTC)) + "\"");
				return FileVisitResult.CONTINUE;
			}
		});
	}

	static final class HumanReadableException extends Exception
	{
		HumanReadableException(final String message)
		{
			super(message);
		}
		private static final long serialVersionUID = 1l;
	}

	private VaultFileToTrail()
	{
		// prevent instantiation
	}
}

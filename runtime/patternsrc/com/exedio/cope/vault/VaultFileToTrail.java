/*
 * Copyright (C) 2004-2015  exedio GmbH (www.exedio.com)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package com.exedio.cope.vault;

import static java.lang.Integer.parseInt;
import static java.time.ZoneOffset.UTC;

import com.exedio.cope.util.CharSet;
import com.exedio.cope.util.Hex;
import com.exedio.cope.util.Sources;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

/**
 * You may generate a dump file for importing into the database calling:
 * <pre>
 *    java -cp exedio-cope.jar:exedio-cope-util.jar com.exedio.cope.vault.VaultFileToTrail &lt;root-dir&gt; &lt;service-key&gt; &gt; vaultrail.sql
 * </pre>
 */
public final class VaultFileToTrail
{
	public static void main(final String[] args)
	{
		try
		{
			mainInternal(System.out, System.err, args);
		}
		catch(final HumanReadableException e)
		{
			System.err.println("ERROR: " + e.getMessage());
			//noinspection CallToSystemExit
			System.exit(1);
		}
		catch(final IOException e)
		{
			System.err.println("ERROR");
			e.printStackTrace(System.err);
			//noinspection CallToSystemExit
			System.exit(1);
		}
	}

	static void mainInternal(
			final PrintStream out,
			final PrintStream err,
			final String... args)
			throws HumanReadableException, IOException
	{
		if(args.length<1)
			throw new HumanReadableException(
					"root directory must be specified as first parameter");
		if(args.length<2)
			throw new HumanReadableException(
					"service key must be specified as second parameter");

		final TrailProperties defaultProvider =
				new TrailProperties(Sources.EMPTY);
		main(out, err,
				Paths.get(args[0]),
				args[1],
				args.length>2 ? parseInt(args[2]) : defaultProvider.startLimit);
	}

	private static void main(
			final PrintStream out,
			final PrintStream err,
			final Path root,
			final String serviceKey,
			final int startLimit)
			throws HumanReadableException, IOException
	{
		if(!Files.exists(root))
			throw new HumanReadableException(
					"root directory does not exist: " + root.toAbsolutePath());
		if(!Files.isDirectory(root))
			throw new HumanReadableException(
					"root directory is not a directory: " + root.toAbsolutePath());

		out.println("-- Generated by " + VaultFileToTrail.class.getName());
		out.println("--   root=" + root.toAbsolutePath());
		out.println("--   serviceKey=" + serviceKey);
		out.println("--   startLimit=" + startLimit);
		out.println("SET TIME_ZONE='+00:00';");

		final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

		final String origin = VaultFileToTrail.class.getSimpleName();

		Files.walkFileTree(root, new SimpleFileVisitor<>()
		{
			private final ArrayList<String> previousHashes = new ArrayList<>();
			private String directoryHashes = null;
			@Override
			public FileVisitResult preVisitDirectory(final Path dir, final BasicFileAttributes attrs)
			{
				final String filename = dir.getFileName().toString();
				if(directoryHashes==null)
				{
					directoryHashes = "";
					return FileVisitResult.CONTINUE;
				}
				if(CharSet.HEX_LOWER.indexOfNotContains(filename)>=0)
				{
					err.println("Skipping non-hex directory " + dir.toAbsolutePath());
					return FileVisitResult.SKIP_SUBTREE;
				}
				final String newHash = directoryHashes + filename;
				previousHashes.add(directoryHashes);
				directoryHashes = newHash;
				return FileVisitResult.CONTINUE;
			}

			@Override
			public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException
			{
				super.postVisitDirectory(dir, exc); // fails if exc!=null
				directoryHashes = previousHashes.isEmpty() ? null : previousHashes.remove(previousHashes.size()-1);
				return FileVisitResult.CONTINUE;
			}

			@Override
			public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs)
					throws IOException
			{
				if(!Files.isRegularFile(file)) // TODO junit test
				{
					err.println("Skipping non-regular file " + file.toAbsolutePath());
					return FileVisitResult.CONTINUE;
				}

				final String filename = file.getFileName().toString();
				if(CharSet.HEX_LOWER.indexOfNotContains(filename)>=0)
				{
					err.println("Skipping non-hex file " + file.toAbsolutePath());
					return FileVisitResult.CONTINUE;
				}

				final long length = Files.size(file);
				if(length==0)
				{
					err.println("Skipping empty file " + file.toAbsolutePath());
					return FileVisitResult.CONTINUE;
				}

				final byte[] start = new byte[(int)Math.min(length, startLimit)];
				try(var in = Files.newInputStream(file))
				{
					final int result = in.read(start);
					if(result!=start.length)
						throw new IllegalStateException("" + result + '/' + start.length + '/' + file.toAbsolutePath());
				}

				out.println(
						"INSERT IGNORE INTO `VaultTrail_" + serviceKey + "`" +
						"(`hash`,`length`,`start20`,`date`,`origin`) " +
						"VALUES (" +
						"'" + directoryHashes + filename + "'" + "," +
						length + "," +
						"x'" + Hex.encodeLower(start) + "'" + "," + // https://dev.mysql.com/doc/refman/5.7/en/hexadecimal-literals.html
						"{ts '" + dateFormatter.format(LocalDateTime.ofInstant(Files.getLastModifiedTime(file).toInstant(), UTC)) + "'}" + "," +
						"'" + origin + "'" + ");");
				return FileVisitResult.CONTINUE;
			}
		});
	}

	static final class HumanReadableException extends Exception
	{
		HumanReadableException(final String message)
		{
			super(message);
		}
		private static final long serialVersionUID = 1l;
	}

	private VaultFileToTrail()
	{
		// prevent instantiation
	}
}

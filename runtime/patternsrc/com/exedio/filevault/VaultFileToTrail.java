/*
 * Copyright (C) 2004-2015  exedio GmbH (www.exedio.com)
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package com.exedio.filevault;

import static java.lang.Integer.parseInt;
import static java.nio.charset.StandardCharsets.US_ASCII;
import static java.time.ZoneOffset.UTC;

import com.exedio.cope.transientvault.VaultTransientService;
import com.exedio.cope.util.Hex;
import com.exedio.cope.util.Sources;
import com.exedio.cope.vault.VaultProperties;
import java.io.IOException;
import java.io.PrintStream;
import java.io.Serial;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Locale;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicLong;

/**
 * You may generate a csv file for importing into the database calling:
 * <pre>
 *    java -cp exedio-cope.jar:exedio-cope-util.jar com.exedio.filevault.VaultFileToTrail &lt;root-dir&gt; &gt; vault-trail.csv
 * </pre>
 * You may import the csv on MySQL into a table like this:
 * <pre>
 *    CREATE TABLE VaultFileToTrail (
 *       hash varchar(128) PRIMARY KEY,
 *       length bigint NOT NULL,
 *       start20 varchar(40) NOT NULL,
 *       dateEpoch bigint NOT NULL,
 *       date varchar(128) NOT NULL)
 * </pre>
 * with the command
 * <pre>
 *    LOAD DATA INFILE '/var/lib/mysql-files/vault-trail.csv'
 *      INTO TABLE VaultFileToTrail
 *      FIELDS TERMINATED BY ',' ENCLOSED BY '"'
 *      LINES TERMINATED BY '\n'
 *      IGNORE 4 LINES
 * </pre>
 * You may verify the consistency of the length field with
 * <pre>
 *    SELECT COUNT(*) FROM VaultTrail_default a
 *    JOIN VaultFileToTrail b ON a.hash=b.hash
 *    WHERE a.length&lt;&gt;b.length
 * </pre>
 * To verify the consistency of the start field, change the where clause to
 * <pre>
 *    WHERE HEX(a.start20)&lt;&gt;UPPER(b.start20)
 * </pre>
 */
public final class VaultFileToTrail
{
	public static void main(final String[] args)
	{
		try
		{
			mainInternal(System.out, System.err, args);
		}
		catch(final HumanReadableException e)
		{
			System.err.println("ERROR: " + e.getMessage());
			//noinspection CallToSystemExit
			System.exit(1);
		}
		catch(final IOException e)
		{
			System.err.println("ERROR");
			e.printStackTrace(System.err);
			//noinspection CallToSystemExit
			System.exit(1);
		}
	}

	static void mainInternal(
			final PrintStream out,
			final PrintStream err,
			final String... args)
			throws HumanReadableException, IOException
	{
		if(args.length<1)
			throw new HumanReadableException(
					"root directory must be specified as first parameter");

		main(out, err,
				Paths.get(args[0]),
				args.length>1 ? parseInt(args[1]) : startLimitDefault());
	}

	private static int startLimitDefault()
	{
		final Properties rr = new Properties();
		rr.setProperty("default.service", VaultTransientService.class.getName());
		return VaultProperties.factory().
				create(Sources.view(rr, VaultTransientService.class.getName())).
				bucket("default").
				getTrailStartLimit();
	}

	@SuppressWarnings("ConfusingMainMethod")
	private static void main(
			final PrintStream out,
			final PrintStream err,
			final Path root,
			final int startLimit)
			throws HumanReadableException, IOException
	{
		if(!Files.exists(root))
			throw new HumanReadableException(
					"root directory does not exist: " + root.toAbsolutePath());
		if(!Files.isDirectory(root))
			throw new HumanReadableException(
					"root directory is not a directory: " + root.toAbsolutePath());

		out.println("# Generated by " + VaultFileToTrail.class.getName());
		final String spec = VaultFileToTrail.class.getPackage().getSpecificationVersion();
		if(spec!=null)
			out.println("#   " + spec);
		out.println("#   root=" + root.toAbsolutePath());
		out.println("#   startLimit=" + startLimit);

		final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS", Locale.US);

		final byte[] probePrefix = truncate(CONTRACT_PROBE_PREFIX, startLimit).getBytes(US_ASCII);
		final AtomicLong probes = new AtomicLong(0);

		Files.walkFileTree(root, new VaultFileServiceVisitor(err)
		{
			@Override
			void onFile(final String hash, final Path file, final long length) throws IOException
			{
				final byte[] start = new byte[(int)Math.min(length, startLimit)];
				try(var in = Files.newInputStream(file))
				{
					final int result = in.read(start);
					if(result!=start.length)
						throw new IllegalStateException(result + "/" + start.length + '/' + file.toAbsolutePath());
				}

				{
					final int l = Math.min(probePrefix.length, start.length);
					if(Arrays.equals(probePrefix, 0, l, start, 0, l))
					{
						probes.incrementAndGet();
						return;
					}
				}

				final Instant lastModified = Files.getLastModifiedTime(file).toInstant();
				out.println(
						"\"" + hash + "\",\"" +
						length + "\",\"" +
						Hex.encodeLower(start) + "\",\"" +
						lastModified.getEpochSecond() + "\",\"" +
						dateFormatter.format(LocalDateTime.ofInstant(lastModified, UTC)) + "\"");
			}
		});
		err.println("Skipped contract probes: " + probes);
	}

	static final class HumanReadableException extends Exception
	{
		HumanReadableException(final String message)
		{
			super(message);
		}
		@Serial
		private static final long serialVersionUID = 1l;
	}

	/**
	 * Must be consistent to {@code ContractProbe}.
	 */
	private static final String CONTRACT_PROBE_PREFIX = "Test file for " + VaultProperties.class.getName() + "#probe ";

	private static String truncate(final String s, final int limit)
	{
		return s.length()>limit ? s.substring(0, limit) : s;
	}

	private VaultFileToTrail()
	{
		// prevent instantiation
	}
}

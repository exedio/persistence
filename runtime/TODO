
TODO for cope runtime

- constraints
	- range (minimum/maximum) for LongField
	- precision (number of fractional digits) for doubles (see PriceField)
	- unique constraints over multiple fields:
		strictly define what happens with null
- search API
	- oracle statistics
	- group by
	- allow accessing features of subtypes of bound types
	- condition DataField.is[Not]Null
		use this on Media for CheckConstraint
	- order by with customizable null low/high
- application triggered Save Points for partial transaction rollback
- EnumField:
	* optionally put strings in DB
- EnumSetField and EnumMapField should implement Settable
- Media:
	* maintain charset in Content-Type for texts
	* optionally maintain filename param in Content-Disposition header
	* implement MediaAlias
	* redundantly maintain width/height for images
	* store text/* gzipped and deliver as such to the browser
- interface Deletable, to allow explicitly deleting items
	otherwise its forbidden.
- Global History / Undo facility for backoffice, that can undo deletes as well.
- MySQL: warning, if row could exceed 8000 bytes limit
- feature reuse with copy() for Order.articleName
	* copy() for all features
- Connection Pool: throw exception, if transaction is not closed when putting back to pool
- enable clustering
	* make revisions cluster aware
	* test configuration of tomcat
- move DateField#touch into separate pattern Timestamp
- LimitedListField: allow length terminated instead of null terminated as well
- SetFieldOrdered: SetField with explicit order
- patterns such as PriceField as function for select and orderBy
- Copy Constraint for non-final fields
- allow declaring indexes / other schema modification in SQL.
- use getForeignKeyInfo() etc. from JDBC for verifying dsmf schema
- allow (fulltext) indexes to be declared in java source code,
	and generate useful finders for index.
- test model:
	* put classes for patterns into separate package
	* make small test models for each lib test
- support JMX for information displayed by ConsoleServlet
- separate into own sub-projects:
	* instrumentor

performance / memory consumption
--------------------------------

- ConnectionPool:
	* replace expensive connection testing on retrieval from pool
		by periodic expiry of connections that have not been used for some time.
	* show information about expired connection / last expiry run in console
- Use auto-increment instead of sequences
- ItemCache: store values in three arrays int[], double[], String[] instead of a Map,
	saves lots of objects going through full GC.
	* implement pooling for various classes, especcially when trove LinkedHashMap is done
- QueryCache:
	* implement similar compact representation as for Cache
	* special handling for empty/singleton results saving memory
	* API for enabling cache for single Query, also dependent on result size
- trove:
	* implement equivalent of LinkedHashMap, would avoid clean-up sweeps for Cache#stateMaps
	* implement TObjectObjectHashMap, would provide open hashing instead of chained hashing for Cache#queries
- rethink internal structure of Entity, State, Row
- special handling of searches by unique constraints, bypassing QueryCache

security
--------

- allow separate database account for revisions,
	for minimizing privileges of the normal account.


TODO for cope runtime

- constraints
	- range (minimum/maximum) for LongField
	- precision (number of fractional digits) for doubles (see PriceField)
	- unique constraints over multiple fields:
		strictly define what happens with null
- search API
	- oracle statistics / mysql execution plan
	- group by
	- allow accessing features of subtypes of bound types
	- condition DataField.is[Not]Null
		use this on Media for CheckConstraint
	- function coalesce (replace null by other value)
	- order by with customizable null low/high
- application triggered Save Points for partial transaction rollback
- EnumField:
	* allow modification of integers in DB via annotation
	* optionally put strings in DB
- EnumSetField and EnumMapField should implement Settable
- Media:
	* maintain charset in Content-Type for texts
	* optionally maintain filename param in Content-Disposition header
	* implement MediaAlias
	* redundantly maintain width/height for images
	* store text/* gzipped and deliver as such to the browser
- Hash:
	* support a maximum of failed checks
	* support blocking for a short time after a failed check
- interface Deletable, to allow explicitly deleting items
	otherwise its forbidden.
- pattern Range:
	restrict to Comparable and define check contraint that from<=to,
	once arbitrary check contraints are implemented.
- a pattern Replicator
- Global History / Undo facility for backoffice, that can undo deletes as well.
- MySQL: warning, if row could exceed 8000 bytes limit
- implement Serializable
	* Composite.Value (add tests)
	* Price
- feature reuse with copy() for Order.articleName
	* copy() for all features
- Connection Pool: throw exception, if transaction is not closed when putting back to pool
- enable clustering
	* make revisions cluster aware
	* test configuration of tomcat
	* use auto-increment instead of sequences
- move DateField#touch into separate pattern Timestamp
- FieldListLimited: allow length terminated instead of null terminated as well
- SetFieldOrdered: SetField with explicit order
- patterns such as PriceField as function for select and orderBy
- Cache: store values in three arrays int[], double[], String[] instead of a Map,
	saves lots of objects going through full GC.
	* implement pooling for various classes, especcially when trove LinkedHashMap is done
- QueryCache:
	* implement similar compact representation as for Cache
	* special handling for empty/singleton results saving memory
- Copy Constraint for non-final fields
- allow declaring indexes / other schema modification in SQL.
- trove:
	* implement equivalent of LinkedHashMap, would avoid clean-up sweeps for Cache#stateMaps
	* implement TObjectObjectHashMap, would provide open hashing instead of chained hashing for Cache#queries
- rethink internal structure of Entity, State, Row
- use getForeignKeyInfo() etc. from JDBC for verifying dsmf schema
- allow (fulltext) indexes to be declared in java source code,
	and generate useful finders for index.
- migrate to Oracle 11 from Oracle 9
	* revisit all oracle-specific code in framework and tests
- test model:
	* put classes for patterns into separate package
	* make small test models for each lib test
- support JMX for information displayed by ConsoleServlet
- separate into own sub-projects:
	* instrumentor

performance / memory consumption
--------------------------------

- ConnectionPool:
	* replace expensive connection testing on retrieval from pool
		by periodic expiry of connections that have not been used for some time.
	* show information about expired connection / last expiry run in console
